# Day 14
library(purrr)
library(dplyr)
library(stringr)
library(readr)
library(logger)
library(usethis)

wrangle_polymer_data <- function(raw_data) {
  template <- head_while(raw_data, ~  str_length(.x) > 0) |>
    str_split("") |>
    unlist()
    
  pairs <- tail_while(raw_data, ~ str_length(.x) > 0) |>
    map(~ ( unlist(str_split( .x, fixed( " -> ") ) ) ) ) |>
    transpose()
  
  #pairs2 <- map(pairs[[1]], pairs[[2]], ~ list(paste0(substr(x,1,1), y) paste0(substr(x,2,1),y)) )
  pair_rules <- pairs[[2]]
  names(pair_rules) <- pairs[[1]]
 
   
  return (list(template=template, pair_rules = pair_rules))
}

# calculate letters to insert into template tp for lookup table lk
insert <- function(tp, lk) {
  log_info("Making template, length {length(tp)}")
  
  map2(tp, lead(tp), ~ paste0( .x, .y ) ) |>
  map( ~ lk[[.x]]) |>
  unlist()
}

insert1 <- function(tp, lk) {
  log_info("Making template, length {length(tp)}")
  
  insert <- vector ("character", length(tp)-1)
  for (i in 1:length(tp)-1 ) {
    pair <- paste0(tp[i],tp[i+1])
    insert[i] <- lk[pair]
    aa<-2
  }
  return(insert)
  #map2(tp, lead(tp), ~ paste0( .x, .y ) ) |>
  #map( ~ lk[[.x]]) |>
  #unlist()
}

# zip template tp with insert letters as vector.
zip <- function (tp, insert) {
 # reduce(seq_along(insert), .init=tp , \(x, i) append(x, insert[i], after=i*2-1))
  result<-  reduce2 ( tail(tp, -1), insert, .init=tp[1], \(c, t, i) c(c, i ,t))#
  aa<-2
  return(result)
}
  
zip1 <- function (tp, insert) {
  # new1 <- vector("character", length(tp) + length(insert))
  new1 <- vector("character", length(tp) + length(insert))
 # reduce(seq_along(insert), .init=tp , \(x, i) append(x, insert[i], after=i*2-1))
  
  # reduce2 ( tail(tp, -1), insert, .init=tp[1], \(c, t, i) c(c, i ,t))#
  
  # new2 <- reduce(seq_along(tp), .init=new1, \(x,i) {x[(i*2-1)] <- tp[i]; x})
  # new3 <- reduce(seq_along(insert), .init=new2, \(y,j) {y[j*2] <- insert[j]; y})
  new1[1] <- tp[1] 
  for (i in 1:length(insert)) {
    new1[i*2] <- insert[i]
    new1[i*2 +1] <- tp[i+1]
  }
  
  return(unlist(new1))
}

# run the template n steps through the insert generation and zipping.
make_polymer <- function (tp, lk, n) {
  reduce(1:n, .init=tp, \(x, i) zip(x, insert(x, lk) ) )
}
# run the template n steps through the insert generation and zipping.
make_polymer1 <- function (tp, lk, n) {
  reduce(1:n, .init=tp, \(x, i) zip1(x, insert(x, lk) ) )
}

get_polymer_metric <- function (raw_polymer_data, steps=10) {
  polymer_data <- wrangle_polymer_data(raw_polymer_data)
  # lookup table for pair rules to insert value.
  lk <- polymer_data$pair_rules
  # polymer starting template.
  tp <- polymer_data$template
  
  e_counts <- make_polymer(tp, lk, steps) |>
     as_tibble(.name_repair="unique") |>
     count(value) |>
     arrange(n)
  
  most_minus_least_e <- tail(e_counts$n, 1) - head(e_counts$n, 1)
  
  return (most_minus_least_e)
} 

get_polymer_metric1 <- function (raw_polymer_data, steps=10) {
  polymer_data <- wrangle_polymer_data(raw_polymer_data)
  # lookup table for pair rules to insert value.
  lk <- polymer_data$pair_rules
  # polymer starting template.
  tp <- polymer_data$template
  
  e_counts <- make_polymer1(tp, lk, steps) |>
     as_tibble(.name_repair="unique") |>
    count(value) |>
    arrange(n)
  
  most_minus_least_e <- tail(e_counts$n, 1) - head(e_counts$n, 1)
  
  return (most_minus_least_e)
} 
 
# Task 2 alternative approach

polymer_data <- wrangle_polymer_data(test_day14_data)
pr <- polymer_data$pair_rules
  
#map2(names(pr), pr, ~  pair_list(.x, .y)  )

#' Make matrix which will perform the effect of insertions on the list of pairs.
#' @param pr pair rules.
#' @return logcial matrix with each row specifying the two new pairs produced
#' by insertion rules.
make_insertion_matrix <- function (pr) {
map2(names(pr), pr, ~ make_ins_row(pr, pair_list(.x, .y))) |>
  reduce(append) |>
  matrix(
    ncol = length(pair_rules),
    byrow = TRUE,
    dimnames = list(names(pr), names(pr))
  )
}
pr<- pair_rules
# Make matrix row for given pair of insertions using pair rules
#'@param pr pair rules  
#'@param pair pair to insert 
#'@return matix row for transformation matrix
make_ins_row <- function (pr, pair) {
  map_dbl( names(pr), ~ ifelse( .x %in% pair, 1, 0 ))
}
# make list of pairs which are generated by insertion this name value pair.
pair_list <- function (n, v) {
  list( paste0(substr(n,1,1),v), paste0(v, substr(n,2,2) ))
}

tp <- polymer_data$template

template_pairs <-  map2(tp, lead(tp), ~ paste0(.x, .y)) |> head (-1 )
initial_counts <-   map_dbl(names(pr), ~ ifelse(.x %in% template_pairs, 1,0 ))

ins_m <- make_insertion_matrix(pr)

pair_counts <- reduce( 1:10 , .init=initial_counts, ~ .x %*% ins_m) |>
  set_names(names(pr))


letters <-
  imap(pair_counts, ~ list(c(substr(.y, 1, 1), .x), c(substr(.y, 2, 2), .x))) |>
  flatten() |>
  transpose()

df_counts <-  tibble (let = letters[[1]], 
                      count = as.numeric( letters[[2]]) ) |>
  group_by(let)|>
  summarise(total = sum(count)) |>
  arrange(total)

  
most_minus_least_l <- tail(df_counts$total, 1) - head(df_counts$total, 1)
