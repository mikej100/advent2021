# Day 14
library(purrr)
library(dplyr)
library(stringr)
library(tibble)
library(readr)
library(logger)
library(usethis)

wrangle_polymer_data <- function(raw_data) {
  template <- head_while(raw_data, ~  str_length(.x) > 0) |>
    str_split("") |>
    unlist()
    
  pairs <- tail_while(raw_data, ~ str_length(.x) > 0) |>
    map(~ ( unlist(str_split( .x, fixed( " -> ") ) ) ) ) |>
    transpose()
  
  pair_rules <- pairs[[2]]
  names(pair_rules) <- pairs[[1]]
   
  return (list(template=template, pair_rules = pair_rules))
}

# calculate letters to insert into template tp for lookup table lk
insert <- function(tp, lk) {
  log_debug("Making insert, length {length(tp)}")
  
  map2(tp, lead(tp), ~ paste0( .x, .y ) ) |>
  map( ~ lk[[.x]]) |>
  unlist()
}

# Try to make faster version of insert.
insert1 <- function(tp, lk) {
  log_debug("Making template, length {length(tp)}")
  
  insert <- vector ("character", length(tp)-1)
  for (i in 1:length(tp)-1 ) {
    pair <- paste0(tp[i],tp[i+1])
    insert[i] <- lk[pair]
    aa<-2
  }
  return(insert)
}

# zip template tp with insert letters as vector.
zip <- function (tp, insert) {
  result<-  reduce2 ( tail(tp, -1), insert, .init=tp[1], \(c, t, i) c(c, i ,t))#
  return(result)
}
  
# Try to make faster version of zip.
zip1 <- function (tp, insert) {
  new1 <- vector("character", length(tp) + length(insert))
  
  new1[1] <- tp[1] 
  for (i in 1:length(insert)) {
    new1[i*2] <- insert[i]
    new1[i*2 +1] <- tp[i+1]
  }
  
  return(unlist(new1))
}

# run the template n steps through the insert generation and zipping.
make_polymer <- function (tp, lk, n) {
  reduce(1:n, .init=tp, \(x, i) zip(x, insert(x, lk) ) )
}
# try to make faster version of make_polymer.
make_polymer1 <- function (tp, lk, n) {
  reduce(1:n, .init=tp, \(x, i) zip1(x, insert(x, lk) ) )
}

get_polymer_metric <- function (raw_polymer_data, steps=10) {
  log_info("Start get_polymer_metric, steps: {steps}")
  log_start_time <- Sys.time()
  
  polymer_data <- wrangle_polymer_data(raw_polymer_data)
  # lookup table for pair rules to insert value.
  lk <- polymer_data$pair_rules
  # polymer starting template.
  tp <- polymer_data$template
  
  logdata_polymer <- make_polymer(tp,lk,steps)|> reduce(~paste0(.x,.y))
  log_debug(" steps: {steps}, polymer {logdata_polymer}")
  
  e_counts <- make_polymer(tp, lk, steps) |>
     as_tibble(.name_repair="unique") |>
     count(value) |>
     arrange(n)
  
  most_minus_least_e <- tail(e_counts$n, 1) - head(e_counts$n, 1)
  
  log_elapsed <- difftime(Sys.time(), log_start_time, units="secs")
  log_info("Finish get_polymer_metric, steps: {steps}, elapsed: {log_elapsed}")
  return (most_minus_least_e)
} 

get_polymer_metric1 <- function (raw_polymer_data, steps=10) {
  log_info("Start get_polymer_metric1, steps: {steps}")
  log_start_time <- Sys.time()
  
  polymer_data <- wrangle_polymer_data(raw_polymer_data)
  # lookup table for pair rules to insert value.
  lk <- polymer_data$pair_rules
  # polymer starting template.
  tp <- polymer_data$template
  
  e_counts <- make_polymer1(tp, lk, steps) |>
     as_tibble(.name_repair="unique") |>
    count(value) |>
    arrange(n)
  
  most_minus_least_e <- tail(e_counts$n, 1) - head(e_counts$n, 1)
  
  log_elapsed <- difftime(Sys.time(), log_start_time, units="secs")
  log_info("Finish get_polymer_metric1, steps: {steps}, elapsed: {log_elapsed}")
  
  return (most_minus_least_e)
} 
 
# Task 2 alternative approach
  
#map2(names(pr), pr, ~  pair_list(.x, .y)  )

#' Make matrix which will perform the effect of insertions on the list of pairs.
#' @param pr pair rules.
#' @return logcial matrix with each row specifying the two new pairs produced
#' by insertion rules.
make_insertion_matrix <- function (pr) {
map2(names(pr), pr, ~ make_ins_row(pr, pair_list(.x, .y))) |>
  reduce(append) |>
  matrix(
    ncol = length(pr),
    byrow = TRUE,
    dimnames = list(names(pr), names(pr))
  )
}
# Make matrix row for given pair of insertions using pair rules
#'@param pr pair rules  
#'@param pair pair to insert 
#'@return matix row for transformation matrix
make_ins_row <- function (pr, pair) {
  map_dbl( names(pr), ~ ifelse( .x %in% pair, 1, 0 ))
}

# make list of pairs which are generated by insertion this name value pair.
pair_list <- function (n, v) {
  list(paste0(substr(n, 1, 1), v), paste0(v, substr(n, 2, 2)))
}

# generate vector of zeros on which to build mask of pairs defined pr
#'@param pr pair rules  
#'@return vector of zeros.
zero_mask <- function(pr) {
  mask <- rep(0, length(pr))
  names(mask) <- names(pr)
  return(mask)
}

#' Generate a vector mask for the pair 
#' @param pair pair to encode
#' @param pr pair rules 
#' @return vector of length of pr, value zero except for the pair with value 1
pair_mask <- function(pair, pr) {
  mask <- zero_mask(pr)
  mask[pair] <- 1
  return (mask)
  
}
get_initial_counts <- function (tp, pr) {
  template_pairs <- map2(tp, lead(tp), ~ paste0(.x, .y)) |> 
    head (-1)
  
  reduce(template_pairs,
         .init = zero_mask(pr),
         ~ .x + pair_mask(.y, pr))
}

get_polymer_metric_fast <- function (raw_polymer_data, steps = 10) {
  log_info("Start get_polymer_metric_fast, steps: {steps}")
  log_start_time <- Sys.time()
  
  polymer_data <- wrangle_polymer_data(raw_polymer_data)
  pr <- polymer_data$pair_rules
  tp <- polymer_data$template
  
  initial_counts <- get_initial_counts(tp, pr)
  
  # set up the insertions matrix.
  ins_mat <- make_insertion_matrix(pr)
  
  # run the insertions matrix for all the steps
  pair_counts <-
    reduce(1:steps , .init = initial_counts, ~ .x %*% ins_mat) |>
    set_names(names(pr))
  
# Need to add the last letter
  
  letters <-
    imap(pair_counts, ~ c( substr(.y, 1, 1), .x)) |>
    append(list(last=c(tail(tp, 1), '1')))  |>
    transpose()
  
  logdata_letters <-  tibble(count=letters[[2]]) |> filter(count>=1) 
  log_debug("steps: {steps}, letters: {logdata_letters}")
  
  df_counts <-  tibble (let = letters[[1]],
                        count = as.numeric(letters[[2]])) |>
    group_by(let) |>
    summarise(total = sum(count)) |>
    arrange(total)
  
  
  most_minus_least_l <-
    tail(df_counts$total, 1) - head(df_counts$total, 1)
 
  log_elapsed <- difftime(Sys.time(), log_start_time, units="secs")
  log_info("Finish get_polymer_metric_fast, steps: {steps}, time: {log_elapsed}")
  return (most_minus_least_l)
}

# Utility used to debug fast version of solution by looking for differences
# between the intermidiate data generated in the slow and fast implementations.
# In practice, this helped identify the error in the initial counts only found
# in task 2.
compare_polymer  <- function (raw_polymer_data, steps) {
  
  polymer_data <- wrangle_polymer_data(raw_polymer_data)
  pr <- polymer_data$pair_rules
  tp <- polymer_data$template
  
  # Set up polymer with slow method
  poly_slow <-   make_polymer(tp, pr, steps) 
  poly_pairs_slow <- map2( poly_slow, lead(poly_slow), ~ paste0(.x, .y)) |>
    unlist()
  
  pps_df <- poly_pairs_slow |>
    tibble(.name_repair = \(.x)"pair") |>
    group_by(pair) |>
    count(pair)
  
  # Set up polymer pairs with fast method. 
  initial_counts <- get_initial_counts(tp, pr)
  
  # set up the insertions matrix.
  ins_mat <- make_insertion_matrix(pr)
  
  # run the insertions matrix for all the steps
  pair_counts <-
    reduce(1:steps , .init = initial_counts, ~ .x %*% ins_mat) |>
    set_names(names(pr)) |>
    t()|>
    enframe(name="pair", value="fast_count")
  
  cf <- full_join(pps_df, pair_counts ) |>
    filter (n != fast_count)
  
  return(list(poly=reduce(poly_slow, ~paste0(.x,.y)), cf=cf, mat=ins_mat,
              tp=reduce(tp, ~paste0(.x, .y))  ))
  
}

#  res <- compare_polymer(day14_data, 10 ) 
# 
# res$poly
# res$tp
# res$cf
# res$mat[]
